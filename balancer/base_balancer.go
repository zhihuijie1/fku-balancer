// 基础负载均衡器实现
// 提供了Add和Remove方法的通用实现，供其他负载均衡器继承使用
package balancer

import (
	"sync" // 同步包，提供互斥锁等并发原语
)

// BaseBalancer 是所有负载均衡器的基础结构体
// 提供了通用的主机管理功能和线程安全保证
// 其他具体的负载均衡器通过嵌入（embedding）这个结构体来复用代码
//
// Go语言通过组合而非继承实现代码复用：
// 1. 嵌入结构体可以直接访问被嵌入结构体的字段和方法
// 2. 可以重写（override）被嵌入结构体的方法
// 3. 这是Go实现"继承"的方式，但本质是组合（Composition）
type BaseBalancer struct {
	// sync.RWMutex 是读写互斥锁
	// 特点：
	// 1. 多个goroutine可以同时获取读锁（RLock）
	// 2. 写锁（Lock）是独占的，获取写锁时其他goroutine无法获取读锁或写锁
	// 3. 适用于读多写少的场景，比写互斥锁（sync.Mutex）性能更好
	//
	// 嵌入sync.RWMutex意味着BaseBalancer自动拥有了Lock、Unlock、RLock、RUnlock等方法
	// 这种嵌入方式称为"匿名嵌入"或"提升字段"（promoted fields）
	sync.RWMutex

	// hosts 存储所有可用的后端服务器地址
	// 使用切片而不是数组的原因：
	// 1. 切片是动态的，可以根据需要增长或缩小
	// 2. 切片是引用类型，传递时不会复制底层数组
	// 3. 提供了方便的append、len、cap等操作
	hosts []string
}

// Add 向负载均衡器添加一个新的后端服务器
// 参数 host：要添加的服务器地址（如 "http://192.168.1.100:8080"）
//
// 方法接收者 (b *BaseBalancer) 使用指针的原因：
// 1. 需要修改结构体的内容（hosts切片）
// 2. 避免复制整个结构体，提高性能
// 3. 保证所有调用者看到的是同一个实例
func (b *BaseBalancer) Add(host string) {
	// 获取写锁，确保并发安全
	// 写锁是独占的，同一时刻只有一个goroutine可以修改hosts
	b.Lock()

	// defer 关键字确保函数返回前一定会执行解锁操作
	// 即使函数中出现panic，defer也会执行
	// 这避免了死锁的发生
	defer b.Unlock()

	// 检查主机是否已经存在，避免重复添加
	// 使用简单的线性搜索，时间复杂度O(n)
	// 对于小规模的服务器列表（通常几十个），这是可接受的
	for _, h := range b.hosts {
		if h == host {
			// 主机已存在，直接返回
			// 这里没有返回错误，采用了幂等性设计：
			// 多次添加相同主机的效果与添加一次相同
			return
		}
	}

	// 主机不存在，添加到列表末尾
	// append 是Go的内置函数，用于向切片添加元素
	// 如果底层数组容量不够，append会自动分配新的更大的数组
	b.hosts = append(b.hosts, host)
}

// Remove 从负载均衡器中移除一个后端服务器
// 参数 host：要移除的服务器地址
//
// 移除操作的场景：
// 1. 健康检查发现服务器不可用
// 2. 手动下线服务器进行维护
// 3. 动态缩容
func (b *BaseBalancer) Remove(host string) {
	// 获取写锁，确保并发安全
	b.Lock()
	// 使用defer确保解锁，避免死锁
	defer b.Unlock()

	// 遍历查找要移除的主机
	// 使用索引遍历，因为需要知道元素位置以便删除
	for i, h := range b.hosts {
		if h == host {
			// 找到要移除的主机
			// 使用切片的切片操作删除元素
			// b.hosts[:i] 获取索引i之前的所有元素
			// b.hosts[i+1:] 获取索引i之后的所有元素
			// ... 展开操作符，将切片元素展开作为append的参数
			//
			// 示例：假设hosts = ["A", "B", "C", "D"]，要删除"C"（i=2）
			// b.hosts[:2] = ["A", "B"]
			// b.hosts[3:] = ["D"]
			// 结果：hosts = ["A", "B", "D"]
			b.hosts = append(b.hosts[:i], b.hosts[i+1:]...)

			// 删除成功后立即返回
			// 假设列表中没有重复的主机地址
			return
		}
	}
	// 如果主机不存在，静默处理（不报错）
	// 这也是幂等性设计：移除不存在的主机不算错误
}

// Balance 是负载均衡选择方法的默认实现
// 参数 key：用于某些算法的键值（如客户端IP）
// 返回值：选中的服务器地址和可能的错误
//
// 这是一个空实现，具体的负载均衡算法需要重写这个方法
// 使用空实现而不是抽象方法的原因：
// 1. Go没有抽象类的概念
// 2. 允许某些简单的负载均衡器不实现Balance（虽然不常见）
// 3. 提供默认行为，避免nil指针异常
func (b *BaseBalancer) Balance(key string) (string, error) {
	// 返回空字符串和nil错误
	// 具体的负载均衡器必须重写此方法
	return "", nil
}

// Inc 增加指定服务器的连接计数
// 参数：服务器地址（这里的参数使用下划线_表示忽略）
//
// 这是一个空实现，因为不是所有负载均衡算法都需要追踪连接数
// 例如：
// - round-robin不需要连接计数
// - least-connections需要连接计数
//
// 使用空方法而不是接口分离的原因：
// 保持接口简单统一，避免类型断言
func (b *BaseBalancer) Inc(_ string) {}

// Done 减少指定服务器的连接计数
// 参数：服务器地址（使用下划线_忽略）
//
// 与Inc方法配对使用，标记请求处理完成
// 空实现的原因同Inc方法
//
// 下划线_的作用：
// 1. 表示参数被忽略，不会在函数体中使用
// 2. 避免编译器"声明但未使用"的警告
// 3. 保持接口签名的一致性
func (b *BaseBalancer) Done(_ string) {}

// BaseBalancer的设计模式总结：
// 1. 模板方法模式：提供算法框架，子类实现具体步骤
// 2. 组合优于继承：通过嵌入实现代码复用
// 3. 并发安全：使用读写锁保护共享数据
// 4. 幂等性设计：重复操作不会产生副作用
